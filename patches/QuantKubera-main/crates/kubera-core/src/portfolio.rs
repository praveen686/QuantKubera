//! # Portfolio & Position Tracking
//!
//! Real-time accounting and mark-to-market valuations.
//!
//! ## Description
//! The `Portfolio` system provides the "source of truth" for current holdings,
//! average entry prices, and Profit & Loss (PnL) metrics. It calculates:
//! - **Realized PnL**: Captured upon position reduction or closing.
//! - **Unrealized PnL**: Floating value based on latest market ticks.
//! - **Weighted Average Entry**: Cost-basis tracking for multi-stage fills.
//!
//! ## References
//! - IEEE Std 1016-2009: Software Design Descriptions

use kubera_models::Side;
use std::collections::HashMap;
use tracing::info;

/// Core state container for multi-asset positions.
pub struct Portfolio {
    /// Map of instrument symbols to their respective position state.
    positions: HashMap<String, Position>,
    /// System-wide aggregated realized gain/loss.
    pub realized_pnl: f64,
    pub balance: f64,
}

/// Detailed accounting state for a specific financial instrument.
#[derive(Debug, Clone, Default)]
pub struct Position {
    pub symbol: String,
    pub quantity: f64,
    pub avg_entry_price: f64,
    /// Floating PnL based on the last `mark_to_market` call.
    pub unrealized_pnl: f64,
    /// Cumulative PnL realized from closing trades for this symbol.
    pub realized_pnl: f64,
}

impl Portfolio {
    /// Creates an empty portfolio with zero balances.
    pub fn new() -> Self {
        Self {
            positions: HashMap::new(),
            realized_pnl: 0.0,
            balance: 0.0,
        }
    }
    
    /// Low-level fill processor for updating internal state.
    ///
    /// # Parameters
    /// * `symbol` - The symbol of the instrument traded.
    /// * `side` - Whether the trade was a Buy or Sell.
    /// * `quantity` - Absolute quantity filled.
    /// * `price` - Execution price of the fill.
    ///
    /// # Returns
    /// The realized PnL generated by this specific fill (0.0 if increasing position).
    pub fn apply_fill(&mut self, symbol: &str, side: Side, quantity: f64, price: f64, commission: f64) -> f64 {
        let position = self.positions.entry(symbol.to_string())
            .or_insert_with(|| Position { symbol: symbol.to_string(), ..Default::default() });
        
        let side_mult = match side {
            Side::Buy => 1.0,
            Side::Sell => -1.0,
        };
        
        let trade_qty = side_mult * quantity;
        let prev_qty = position.quantity;
        
        // Calculate gross PnL if reducing position
        let mut trade_pnl = 0.0;
        if (prev_qty > 0.0 && side == Side::Sell) || (prev_qty < 0.0 && side == Side::Buy) {
            let close_qty = trade_qty.abs().min(prev_qty.abs());
            trade_pnl = close_qty * (price - position.avg_entry_price) * prev_qty.signum();
        }
        
        // Net PnL = Gross PnL - Commission
        let net_pnl = trade_pnl - commission;
        position.realized_pnl += net_pnl;
        self.realized_pnl += net_pnl;
        
        // Update position
        let new_qty = prev_qty + trade_qty;
        
        if new_qty.abs() > 1e-10 { // Floating point precision check
            // Weighted average for increasing position
            if prev_qty.signum() == trade_qty.signum() || prev_qty == 0.0 {
                position.avg_entry_price = 
                    ((prev_qty.abs() * position.avg_entry_price) + (quantity * price)) 
                    / (prev_qty.abs() + quantity);
            }
        } else {
            position.avg_entry_price = 0.0;
        }
        
        position.quantity = new_qty;
        
        info!(
            symbol = %symbol,
            side = ?side,
            qty = %quantity,
            price = %price,
            commission = %commission,
            position_qty = %new_qty,
            net_pnl = %net_pnl,
            "Fill applied"
        );
        
        net_pnl
    }
    
    /// Computes unrealized PnL using the provided market price.
    ///
    /// # Parameters
    /// * `current_price` - The latest mark price for the asset.
    pub fn mark_to_market(&mut self, symbol: &str, current_price: f64) -> f64 {
        if let Some(position) = self.positions.get_mut(symbol) {
            position.unrealized_pnl = position.quantity * (current_price - position.avg_entry_price);
            return position.unrealized_pnl;
        }
        0.0
    }
    
    /// Total realized profit/loss since portfolio inception.
    pub fn total_realized_pnl(&self) -> f64 {
        self.realized_pnl
    }
    
    /// Sum of unrealized PnL across all open positions.
    pub fn total_unrealized_pnl(&self) -> f64 {
        self.positions.values().map(|p| p.unrealized_pnl).sum()
    }
    
    /// Retrieves the current position state for a specific symbol.
    pub fn get_position(&self, symbol: &str) -> Option<&Position> {
        self.positions.get(symbol)
    }

    /// Calculates total portfolio value (balance + unrealized PnL).
    /// Requires a map of current market prices.
    pub fn calculate_total_value(&mut self, prices: &HashMap<String, f64>) -> f64 {
        for (symbol, price) in prices {
            self.mark_to_market(symbol, *price);
        }
        // Assuming base balance is tracked separately or implicitly as realized PnL + Initial
        // For this test, user sets public field 'balance' but it's not in struct def above.
        // Let's rely on total_realized + total_unrealized for PnL delta.
        // The test script sets a public field `balance` which doesn't exist.
        // I will add a balance field to the struct first in a separate edit or here if I can.
        // Wait, I can't change struct definition easily without breaking other things maybe.
        // But the test script `portfolio.balance = 10000.0` failed.
        // So I must add `balance` field.
        self.balance + self.total_unrealized_pnl()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_portfolio_buy_then_sell() {
        let mut portfolio = Portfolio::new();

        // Buy 1 BTC @ 50000 (with 0 commission for simple test)
        let pnl1 = portfolio.apply_fill("BTC", Side::Buy, 1.0, 50000.0, 0.0);
        assert_eq!(pnl1, 0.0); // No realized PnL on entry

        let pos = portfolio.get_position("BTC").unwrap();
        assert_eq!(pos.quantity, 1.0);
        assert_eq!(pos.avg_entry_price, 50000.0);

        // Sell 1 BTC @ 55000 (profit)
        let pnl2 = portfolio.apply_fill("BTC", Side::Sell, 1.0, 55000.0, 0.0);
        assert_eq!(pnl2, 5000.0); // $5000 profit

        assert_eq!(portfolio.total_realized_pnl(), 5000.0);
    }

    #[test]
    fn test_portfolio_partial_close() {
        let mut portfolio = Portfolio::new();

        portfolio.apply_fill("ETH", Side::Buy, 10.0, 2000.0, 0.0);
        let pnl = portfolio.apply_fill("ETH", Side::Sell, 5.0, 2500.0, 0.0);

        assert_eq!(pnl, 2500.0); // 5 * (2500 - 2000) = 2500

        let pos = portfolio.get_position("ETH").unwrap();
        assert_eq!(pos.quantity, 5.0);
    }
}
