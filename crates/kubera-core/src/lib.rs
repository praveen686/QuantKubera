//! # QuantKubera Core Module
//!
//! Provides the central event bus and core abstractions for the trading system.
//!
//! ## Description
//! This crate implements the LMAX Disruptor-inspired event processing architecture.
//! It provides a high-performance, lock-free event bus for decoupling market data
//! ingestion, strategy execution, and order routing.
//!
//! ## Architecture
//! ```text
//! ┌─────────────┐    ┌──────────┐    ┌──────────────┐
//! │ Connectors  │───▶│ EventBus │───▶│  Strategies  │
//! └─────────────┘    └──────────┘    └──────────────┘
//!                         │                 │
//!                         ▼                 ▼
//!                    ┌──────────┐    ┌──────────────┐
//!                    │   WAL    │    │ Risk Engine  │
//!                    └──────────┘    └──────────────┘
//! ```
//!
//! ## Performance
//! - Event bus latency: ~230ns (MPSC channels)
//! - Broadcast capacity: Configurable (default 1024)
//!
//! ## Modules
//! - [`strategy`] - Trading strategy abstractions
//! - [`mode`] - Execution mode configuration (paper/live)
//! - [`portfolio`] - Position and PnL tracking
//! - [`connector`] - Market connector trait
//! - [`wal`] - Write-ahead logging for replay
//!
//! ## References
//! - LMAX Disruptor: <https://lmax-exchange.github.io/disruptor/>
//! - IEEE Std 1016-2009: Software Design Descriptions

use kubera_models::{MarketEvent, OrderEvent, SignalEvent, RiskEvent, SystemHealthEvent, FillEvent};
use tokio::sync::broadcast;
use tracing::{warn, info};
use std::sync::Arc;
use async_trait::async_trait;

pub mod strategy;
pub mod mode;
pub mod portfolio;
pub mod connector;
pub mod observability;
pub mod oras;
pub mod hydra;
pub mod metrics;
pub mod aeon;
pub mod parquet_export;

pub use strategy::{Strategy, StrategyRunner, MomentumStrategy};
pub use oras::OrasStrategy;
pub use hydra::HydraStrategy;
pub use aeon::AeonStrategy;

pub use mode::{ExecutionMode, ModeConfig};
pub use portfolio::Portfolio;
pub use metrics::{TradingMetrics, MetricsConfig, MetricsSnapshot, TradeRecord};

/// Unified event container for the QuantKubera ecosystem.
///
/// # Description
/// Decouples event producers from consumers by wrapping all system signals
/// into a single strongly-typed enumeration. This promotes architectural 
/// flexibility and simplifies logging/audit persistence.
pub enum Event {
    /// Incremental price or orderbook updates.
    Market(MarketEvent),
    /// Alpha-driven signals generated by strategies.
    Signal(SignalEvent),
    /// Instructions for order placement, modification, or cancellation.
    Order(OrderEvent),
    /// Security or compliance violations flagged by the `RiskEngine`.
    Risk(RiskEvent),
    /// Diagnostic or operational status updates from internal services.
    Health(SystemHealthEvent),
    /// Verifiable trade execution records for post-trade analysis.
    Fill(FillEvent),
}

/// Central event bus for inter-component communication.
///
/// # Description
/// Implements a pub/sub architecture with separate channels for market data,
/// orders, signals, risk, and health events.
pub struct EventBus {
    /// Broadcast sender for market events (supports multiple subscribers).
    market_sender: broadcast::Sender<MarketEvent>,
    /// Broadcast sender for signal events.
    signal_sender: broadcast::Sender<SignalEvent>,
    /// Broadcast sender for risk events.
    risk_sender: broadcast::Sender<RiskEvent>,
    /// Broadcast sender for system health events.
    health_sender: broadcast::Sender<SystemHealthEvent>,
    /// Broadcast sender for fill events.
    fill_sender: broadcast::Sender<FillEvent>,
    /// Broadcast sender for order instructions (from strategy to executor).
    order_sender: broadcast::Sender<OrderEvent>,
    /// Broadcast sender for order status updates (from executor/connector to strategy/monitor).
    order_update_sender: broadcast::Sender<OrderEvent>,
    
    /// Keep-alive handles.
    _market_handle: broadcast::Receiver<MarketEvent>,
    _risk_handle: broadcast::Receiver<RiskEvent>,
    _health_handle: broadcast::Receiver<SystemHealthEvent>,
    _fill_handle: broadcast::Receiver<FillEvent>,
    _signal_handle: broadcast::Receiver<SignalEvent>,
    _order_handle: broadcast::Receiver<OrderEvent>,
    _order_update_handle: broadcast::Receiver<OrderEvent>,
}

impl EventBus {
    /// Creates a new event bus with specified market data capacity.
    pub fn new(capacity: usize) -> Arc<Self> {
        let (market_sender, _market_handle) = broadcast::channel(capacity);
        let (order_sender, _order_handle) = broadcast::channel(500);
        let (signal_sender, _signal_handle) = broadcast::channel(500);
        let (risk_sender, _risk_handle) = broadcast::channel(100);
        let (health_sender, _health_handle) = broadcast::channel(100);
        let (fill_sender, _fill_handle) = broadcast::channel(500);
        let (order_update_sender, _order_update_handle) = broadcast::channel(500);

        Arc::new(Self {
            market_sender,
            order_sender,
            signal_sender,
            risk_sender,
            health_sender,
            fill_sender,
            order_update_sender,
            _market_handle,
            _risk_handle,
            _health_handle,
            _fill_handle,
            _signal_handle,
            _order_handle,
            _order_update_handle,
        })
    }

    pub async fn publish_market(&self, event: MarketEvent) -> anyhow::Result<()> {
        if let Err(e) = self.market_sender.send(event) {
            warn!("Market data channel lag or no subscribers: {}", e);
        }
        Ok(())
    }

    pub async fn publish_order(&self, event: OrderEvent) -> anyhow::Result<()> {
        if let Err(e) = self.order_sender.send(event) {
            warn!("Order channel lag or no executors: {}", e);
        }
        Ok(())
    }

    pub async fn publish_signal(&self, event: SignalEvent) -> anyhow::Result<()> {
        if let Err(e) = self.signal_sender.send(event) {
            warn!("Signal channel lag or no risk engine/monitor: {}", e);
        }
        Ok(())
    }
    
    pub fn publish_signal_sync(&self, event: SignalEvent) -> anyhow::Result<()> {
        let _ = self.signal_sender.send(event);
        Ok(())
    }

    pub async fn publish_risk(&self, event: RiskEvent) -> anyhow::Result<()> {
        if let Err(e) = self.risk_sender.send(event) {
            warn!("Risk event channel lag or no subscribers: {}", e);
        }
        Ok(())
    }

    pub async fn publish_health(&self, event: SystemHealthEvent) -> anyhow::Result<()> {
        if let Err(e) = self.health_sender.send(event) {
            warn!("Health event channel lag or no subscribers: {}", e);
        }
        Ok(())
    }

    pub async fn publish_fill(&self, event: FillEvent) -> anyhow::Result<()> {
        if let Err(e) = self.fill_sender.send(event) {
            warn!("Fill event channel lag or no subscribers: {}", e);
        }
        Ok(())
    }

    pub fn publish_order_update(&self, event: OrderEvent) -> anyhow::Result<()> {
        if let Err(e) = self.order_update_sender.send(event) {
            warn!("Order update channel lag or no subscribers: {}", e);
        }
        Ok(())
    }

    pub fn subscribe_market(&self) -> broadcast::Receiver<MarketEvent> {
        self.market_sender.subscribe()
    }

    pub fn subscribe_risk(&self) -> broadcast::Receiver<RiskEvent> {
        self.risk_sender.subscribe()
    }

    pub fn subscribe_health(&self) -> broadcast::Receiver<SystemHealthEvent> {
        self.health_sender.subscribe()
    }

    pub fn subscribe_fill(&self) -> broadcast::Receiver<FillEvent> {
        self.fill_sender.subscribe()
    }

    pub fn subscribe_order_update(&self) -> broadcast::Receiver<OrderEvent> {
        self.order_update_sender.subscribe()
    }

    pub fn subscribe_signal(&self) -> broadcast::Receiver<SignalEvent> {
        self.signal_sender.subscribe()
    }

    pub fn subscribe_order(&self) -> broadcast::Receiver<OrderEvent> {
        self.order_sender.subscribe()
    }
}



/// Write-Ahead Logging (WAL) for persistent audit trails and replay.
pub mod wal {
    use super::*;
    use serde::{Serialize, Deserialize};
    use std::fs::{File, OpenOptions};
    use std::io::{Write, BufWriter};
    use std::path::Path;

    /// Buffered file writer optimized for sequential event logging.
    pub struct WalWriter {
        writer: BufWriter<File>,
    }

    impl WalWriter {
        /// Initializes a new WAL log file or appends to an existing one.
        ///
        /// # Parameters
        /// * `path` - The target filesystem location for the log.
        pub fn new<P: AsRef<Path>>(path: P) -> anyhow::Result<Self> {
            let file = OpenOptions::new()
                .create(true)
                .append(true)
                .open(path)?;
            Ok(Self {
                writer: BufWriter::new(file),
            })
        }

        /// Synchronously persists a market data event.
        pub fn log_event(&mut self, event: &MarketEvent) -> anyhow::Result<()> {
            let serialized = serde_json::to_vec(event)?;
            self.writer.write_all(&serialized)?;
            self.writer.write_all(b"\n")?;
            Ok(())
        }

        /// Persists an order event (New, Fill, Cancel) for auditing.
        pub fn log_order(&mut self, event: &OrderEvent) -> anyhow::Result<()> {
            let serialized = serde_json::to_vec(event)?;
            self.writer.write_all(b"ORDER:")?;
            self.writer.write_all(&serialized)?;
            self.writer.write_all(b"\n")?;
            Ok(())
        }

        /// Records a risk violation event.
        pub fn log_risk(&mut self, event: &RiskEvent) -> anyhow::Result<()> {
            let serialized = serde_json::to_vec(event)?;
            self.writer.write_all(b"RISK:")?;
            self.writer.write_all(&serialized)?;
            self.writer.write_all(b"\n")?;
            Ok(())
        }

        /// Records a fill event.
        pub fn log_fill(&mut self, event: &FillEvent) -> anyhow::Result<()> {
            let serialized = serde_json::to_vec(event)?;
            self.writer.write_all(b"FILL:")?;
            self.writer.write_all(&serialized)?;
            self.writer.write_all(b"\n")?;
            Ok(())
        }

        /// Writes typed metadata to the WAL as JSON.
        /// Line format: META:<json(MetaEvent)>
        /// This is extensible for lot sizes, instrument info, venue configs, etc.
        pub fn write_meta<V: serde::Serialize>(&mut self, key: &str, value: &V) -> anyhow::Result<()> {
            let meta = MetaEvent {
                key: key.to_string(),
                value: serde_json::to_value(value)?,
            };
            let serialized = serde_json::to_vec(&meta)?;
            self.writer.write_all(b"META:")?;
            self.writer.write_all(&serialized)?;
            self.writer.write_all(b"\n")?;
            Ok(())
        }

        /// Records a system health heartbeats or status updates.
        pub fn log_health(&mut self, event: &SystemHealthEvent) -> anyhow::Result<()> {
            let serialized = serde_json::to_vec(event)?;
            self.writer.write_all(b"HEALTH:")?;
            self.writer.write_all(&serialized)?;
            self.writer.write_all(b"\n")?;
            Ok(())
        }

        /// Forces kernel-level sync of buffered data to disk.
        pub fn flush(&mut self) -> anyhow::Result<()> {
            self.writer.flush()?;
            Ok(())
        }
    }

    /// Stream-based reader for historical event data.
    pub struct WalReader {
        reader: std::io::BufReader<File>,
    }

    impl WalReader {
        /// Opens an existing WAL file for data ingestion.
        pub fn new<P: AsRef<Path>>(path: P) -> anyhow::Result<Self> {
            let file = File::open(path)?;
            Ok(Self {
                reader: std::io::BufReader::new(file),
            })
        }

        /// Advances the stream to the next market event, skipping non-market records.
        pub fn next_event(&mut self) -> anyhow::Result<Option<MarketEvent>> {
            use std::io::BufRead;
            let mut line = String::new();
            let bytes_read = self.reader.read_line(&mut line)?;
            if bytes_read == 0 {
                return Ok(None);
            }
            // Skip non-market records
            if line.starts_with("ORDER:")
                || line.starts_with("META:")
                || line.starts_with("RISK:")
                || line.starts_with("FILL:")
                || line.starts_with("HEALTH:")
            {
                return self.next_event();
            }
            let event: MarketEvent = serde_json::from_str(&line)?;
            Ok(Some(event))
        }

        /// Reads all typed metadata records from the WAL file.
        /// Returns key -> JSON value map. Call this early (before replay).
        pub fn read_meta_all(&mut self) -> anyhow::Result<std::collections::HashMap<String, serde_json::Value>> {
            use std::io::{BufRead, Seek, SeekFrom};

            let pos = self.reader.stream_position()?;
            self.reader.seek(SeekFrom::Start(0))?;

            let mut out = std::collections::HashMap::new();
            let mut line = String::new();

            loop {
                line.clear();
                let bytes_read = self.reader.read_line(&mut line)?;
                if bytes_read == 0 {
                    break;
                }
                if line.starts_with("META:") {
                    let json_part = line[5..].trim();
                    if !json_part.is_empty() {
                        if let Ok(meta) = serde_json::from_str::<MetaEvent>(json_part) {
                            out.insert(meta.key, meta.value);
                        }
                    }
                }
            }

            self.reader.seek(SeekFrom::Start(pos))?;
            Ok(out)
        }

        /// Reads lot sizes from WAL metadata.
        /// Returns HashMap<Symbol, LotSize>.
        pub fn read_lot_sizes(&mut self) -> anyhow::Result<std::collections::HashMap<String, u32>> {
            let meta = self.read_meta_all()?;
            match meta.get("lot_sizes") {
                Some(v) => Ok(serde_json::from_value(v.clone())?),
                None => Ok(std::collections::HashMap::new()),
            }
        }

        /// Reads instrument info from WAL metadata.
        pub fn read_instrument_info(&mut self) -> anyhow::Result<Option<serde_json::Value>> {
            let meta = self.read_meta_all()?;
            Ok(meta.get("instrument_info").cloned())
        }

        /// Retrieves the next command/response record.
        pub fn next_order_event(&mut self) -> anyhow::Result<Option<OrderEvent>> {
            use std::io::BufRead;
            let mut line = String::new();
            let bytes_read = self.reader.read_line(&mut line)?;
            if bytes_read == 0 {
                return Ok(None);
            }
            if line.starts_with("ORDER:") {
                let json_part = &line[6..];
                let event: OrderEvent = serde_json::from_str(json_part)?;
                return Ok(Some(event));
            }
            self.next_order_event()
        }

        /// Sequentially reads the next record regardless of its concrete subtype.
        pub fn next_any(&mut self) -> anyhow::Result<Option<WalEvent>> {
            use std::io::BufRead;
            let mut line = String::new();
            let bytes_read = self.reader.read_line(&mut line)?;
            if bytes_read == 0 {
                return Ok(None);
            }
            if line.starts_with("ORDER:") {
                let json_part = &line[6..];
                let event: OrderEvent = serde_json::from_str(json_part)?;
                return Ok(Some(WalEvent::Order(event)));
            }
            if line.starts_with("META:") {
                let json_part = &line[5..];
                let event: MetaEvent = serde_json::from_str(json_part)?;
                return Ok(Some(WalEvent::Meta(event)));
            }
            let event: MarketEvent = serde_json::from_str(&line)?;
            Ok(Some(WalEvent::Market(event)))
        }

        /// Counts total number of market events in the WAL file.
        pub fn count_events(&mut self) -> anyhow::Result<usize> {
            use std::io::{Seek, SeekFrom, BufRead};
            let current_pos = self.reader.stream_position()?;
            self.reader.seek(SeekFrom::Start(0))?;
            
            let mut count = 0;
            let mut line = String::new();
            while self.reader.read_line(&mut line)? > 0 {
                if !line.starts_with("ORDER:") && !line.starts_with("RISK:") && !line.starts_with("FILL:") && !line.starts_with("HEALTH:") {
                    count += 1;
                }
                line.clear();
            }
            self.reader.seek(SeekFrom::Start(current_pos))?;
            Ok(count)
        }

        /// Seeks to the N-th market event in the file.
        pub fn seek_event(&mut self, target_idx: usize) -> anyhow::Result<()> {
            use std::io::{Seek, SeekFrom, BufRead};
            self.reader.seek(SeekFrom::Start(0))?;
            
            let mut current_idx = 0;
            let mut line = String::new();
            while current_idx < target_idx {
                let bytes = self.reader.read_line(&mut line)?;
                if bytes == 0 { break; }
                if !line.starts_with("ORDER:") && !line.starts_with("RISK:") && !line.starts_with("FILL:") && !line.starts_with("HEALTH:") {
                    current_idx += 1;
                }
                line.clear();
            }
            Ok(())
        }
    }

    /// Typed metadata record (key/value JSON) persisted in WAL.
    /// Extensible for lot sizes, instrument info, venue configs, etc.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct MetaEvent {
        pub key: String,
        pub value: serde_json::Value,
    }

    /// Serialization-safe envelope for cross-session data persistence.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum WalEvent {
        Market(MarketEvent),
        Meta(MetaEvent),
        Order(OrderEvent),
        Risk(RiskEvent),
        Fill(FillEvent),
        Health(SystemHealthEvent),
    }
}

// ============================================================================
// PERSISTENT EVENT BUS (C1 FIX)
// ============================================================================

use std::path::PathBuf;

/// EventBus with integrated Write-Ahead Log (WAL) persistence.
///
/// # Description
/// Composes the basic `EventBus` with a `WalWriter` to ensure all critical 
/// events (Market, Order, Risk, etc.) are synchronously persisted before 
/// being broadcast to subscribers. This provides a durable audit trail 
/// required for compliance and deterministic backtesting.
pub struct PersistentEventBus {
    /// Underlying high-performance event bus.
    bus: Arc<EventBus>,
    /// Thread-safe handle to the WAL persistence layer.
    wal_writer: std::sync::Mutex<Option<wal::WalWriter>>,
    /// Canonical path to the open WAL log file.
    wal_path: PathBuf,
}

impl PersistentEventBus {
    /// Initializes a new persistent event bus.
    ///
    /// # Parameters
    /// * `capacity` - Primary buffer size for market data broadcast.
    /// * `wal_path` - Filesystem path for the WAL archive.
    ///
    /// # Returns
    /// An `Arc` handle to the initialized bus.
    pub fn new<P: Into<PathBuf>>(capacity: usize, wal_path: P) -> anyhow::Result<Arc<Self>> {
        let path = wal_path.into();
        let wal_writer = wal::WalWriter::new(&path)?;
        
        Ok(Arc::new(Self {
            bus: EventBus::new(capacity),
            wal_writer: std::sync::Mutex::new(Some(wal_writer)),
            wal_path: path,
        }))
    }

    /// Factory for volatile instances where persistence is not required.
    pub fn new_without_wal(capacity: usize) -> Arc<Self> {
        Arc::new(Self {
            bus: EventBus::new(capacity),
            wal_writer: std::sync::Mutex::new(None),
            wal_path: PathBuf::new(),
        })
    }

    /// Persists and publishes a market data event.
    pub async fn publish_market(&self, event: MarketEvent) -> anyhow::Result<()> {
        if let Ok(mut guard) = self.wal_writer.lock() {
            if let Some(ref mut writer) = *guard {
                if let Err(e) = writer.log_event(&event) {
                    warn!("WAL write failed for market event: {}", e);
                }
            }
        }
        self.bus.publish_market(event).await
    }

    /// Persists and publishes an order instruction.
    pub async fn publish_order(&self, event: OrderEvent) -> anyhow::Result<()> {
        if let Ok(mut guard) = self.wal_writer.lock() {
            if let Some(ref mut writer) = *guard {
                if let Err(e) = writer.log_order(&event) {
                    warn!("WAL write failed for order event: {}", e);
                }
            }
        }
        self.bus.publish_order(event).await
    }

    /// Persists and publishes a risk violation.
    pub async fn publish_risk(&self, event: RiskEvent) -> anyhow::Result<()> {
        if let Ok(mut guard) = self.wal_writer.lock() {
            if let Some(ref mut writer) = *guard {
                let _ = writer.log_risk(&event);
            }
        }
        self.bus.publish_risk(event).await
    }

    /// Persists and publishes a trade execution record.
    pub async fn publish_fill(&self, event: FillEvent) -> anyhow::Result<()> {
        if let Ok(mut guard) = self.wal_writer.lock() {
            if let Some(ref mut writer) = *guard {
                let _ = writer.log_fill(&event);
            }
        }
        self.bus.publish_fill(event).await
    }

    /// Persists and publishes a health status update.
    pub async fn publish_health(&self, event: SystemHealthEvent) -> anyhow::Result<()> {
        if let Ok(mut guard) = self.wal_writer.lock() {
            if let Some(ref mut writer) = *guard {
                let _ = writer.log_health(&event);
            }
        }
        self.bus.publish_health(event).await
    }

    /// Persists and publishes an update to an existing order.
    pub async fn publish_order_update(&self, event: OrderEvent) -> anyhow::Result<()> {
        if let Ok(mut guard) = self.wal_writer.lock() {
            if let Some(ref mut writer) = *guard {
                let _ = writer.log_order(&event);
            }
        }
        self.bus.publish_order_update(event)
    }

    /// Forwards signal events directly to the bus (Transient logic).
    pub async fn publish_signal(&self, event: SignalEvent) -> anyhow::Result<()> {
        self.bus.publish_signal(event).await
    }

    /// Flushes all pending WAL writes to physical media.
    pub fn flush_wal(&self) -> anyhow::Result<()> {
        if let Ok(mut guard) = self.wal_writer.lock() {
            if let Some(ref mut writer) = *guard {
                writer.flush()?;
            }
        }
        Ok(())
    }

    /// Grants access to the underlying broadcast bus.
    pub fn inner(&self) -> &Arc<EventBus> {
        &self.bus
    }

    /// Provides the filesystem path to the write-ahead log.
    pub fn wal_path(&self) -> &std::path::Path {
        &self.wal_path
    }

    pub fn subscribe_market(&self) -> broadcast::Receiver<MarketEvent> {
        self.bus.subscribe_market()
    }

    pub fn subscribe_risk(&self) -> broadcast::Receiver<RiskEvent> {
        self.bus.subscribe_risk()
    }

    pub fn subscribe_order_update(&self) -> broadcast::Receiver<OrderEvent> {
        self.bus.subscribe_order_update()
    }

    pub fn subscribe_signal(&self) -> broadcast::Receiver<SignalEvent> {
        self.bus.subscribe_signal()
    }

    pub fn subscribe_order(&self) -> broadcast::Receiver<OrderEvent> {
        self.bus.subscribe_order()
    }

    /// Replays a historical WAL stream into the current live bus.
    ///
    /// # Parameters
    /// * `wal_path` - Path to the historical log file.
    ///
    /// # Returns
    /// A pair containing the count of (MarketEvents, TotalEvents) replayed.
    pub async fn replay_from_wal<P: AsRef<std::path::Path>>(
        &self,
        wal_path: P,
    ) -> anyhow::Result<(usize, usize)> {
        let mut reader = wal::WalReader::new(wal_path)?;
        let mut market_count = 0;
        let mut total_count = 0;

        while let Some(event) = reader.next_any()? {
            match event {
                wal::WalEvent::Market(e) => {
                    self.bus.publish_market(e).await?;
                    market_count += 1;
                }
                wal::WalEvent::Meta(_) => {
                    // Metadata is read separately via read_meta_all(), skip during replay
                }
                wal::WalEvent::Order(e) => {
                    self.bus.publish_order(e).await?;
                }
                wal::WalEvent::Risk(e) => {
                    self.bus.publish_risk(e).await?;
                }
                wal::WalEvent::Fill(e) => {
                    self.bus.publish_fill(e).await?;
                }
                wal::WalEvent::Health(e) => {
                    self.bus.publish_health(e).await?;
                }
            }
            total_count += 1;
        }

        info!("WAL replay complete: {} total events ({} market)", total_count, market_count);
        Ok((market_count, total_count))
    }
}

// ============================================================================
// PAPER TRADING CONNECTOR
// ============================================================================

use crate::connector::MarketConnector;

/// Integration bridge for real-time market simulation.
///
/// # Description
/// Leverages the Decorator pattern to wrap any `MarketConnector`. It 
/// diverts order flow from live venues while maintaining real-time 
/// market data streams, creating an "Order Sandbox" for live-market simulation.
pub struct PaperTradingConnector<C: MarketConnector> {
    /// The live data source (e.g., Binance, Zerodha).
    live_connector: C,
    /// Destination bus for simulated results.
    bus: Arc<EventBus>,
    /// Internal state toggle.
    is_paper: bool,
}

impl<C: MarketConnector> PaperTradingConnector<C> {
    /// Wraps a live connector for paper trading.
    pub fn new(live_connector: C, bus: Arc<EventBus>) -> Self {
        Self {
            live_connector,
            bus,
            is_paper: true,
        }
    }

    pub fn is_paper_mode(&self) -> bool {
        self.is_paper
    }

    pub fn event_bus(&self) -> Arc<EventBus> {
        Arc::clone(&self.bus)
    }
}

#[async_trait]
impl<C: MarketConnector + Send + Sync> MarketConnector for PaperTradingConnector<C> {
    /// Proxies the startup signal to the underlying live venue.
    async fn run(&self) -> anyhow::Result<()> {
        info!("PaperTradingConnector: Starting with live market data, simulated fills");
        self.live_connector.run().await
    }

    fn stop(&self) {
        self.live_connector.stop();
    }

    fn name(&self) -> &'static str {
        "PaperTrading"
    }
}
