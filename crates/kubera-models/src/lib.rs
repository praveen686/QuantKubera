//! # Trading Event Models Module
//!
//! Defines core event types for the QuantKubera trading system.
//!
//! ## Description
//! This module provides the canonical data structures for all events flowing
//! through the system: market data, signals, orders, and portfolio updates.
//! All types implement `Serialize`/`Deserialize` for persistence and IPC.
//!
//! ## Event Hierarchy
//! ```text
//! Events
//! ├── MarketEvent (ticks, bars, L2 updates)
//! ├── SignalEvent (strategy signals)
//! ├── OrderEvent (order lifecycle)
//! └── PortfolioSnapshot (position state)
//! ```
//!
//! ## References
//! - IEEE Std 1016-2009: Software Design Descriptions
//! - FIX Protocol 5.0 SP2 for field naming conventions

use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};
use uuid::Uuid;

/// Market data event from exchange or data feed.
///
/// # Description
/// Encapsulates all market data types: ticks, OHLCV bars, and Level 2 updates.
/// Used as the primary input to strategies.
///
/// # Fields
/// * `exchange_time` - Timestamp from exchange (authoritative)
/// * `local_time` - Local receipt timestamp for latency measurement
/// * `symbol` - Trading symbol (e.g., "BTCUSDT")
/// * `payload` - Specific data type ([`MarketPayload`])
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MarketEvent {
    /// Exchange-provided timestamp (authoritative for sequencing).
    pub exchange_time: DateTime<Utc>,
    /// Local receipt time for latency metrics.
    pub local_time: DateTime<Utc>,
    /// Symbol identifier (e.g., "BTCUSDT", "NIFTY 50").
    pub symbol: String,
    /// Event payload variant.
    pub payload: MarketPayload,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum MarketPayload {
    Tick {
        price: f64,
        size: f64,
        side: Side,
    },
    /// Individual trade event with trade ID.
    Trade {
        /// Trade ID from exchange.
        trade_id: i64,
        /// Trade price.
        price: f64,
        /// Trade quantity.
        quantity: f64,
        /// True if buyer was market maker.
        is_buyer_maker: bool,
    },
    Bar {
        open: f64,
        high: f64,
        low: f64,
        close: f64,
        volume: f64,
        interval_ms: u64,
    },
    L2Update(L2Update),
    L2Snapshot(L2Snapshot),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct L2Update {
    pub bids: Vec<L2Level>,
    pub asks: Vec<L2Level>,
    /// First update ID in this event (U) - used for Binance sequencing
    pub first_update_id: u64,
    /// Last update ID in this event (u) - the primary sequence number
    pub last_update_id: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct L2Snapshot {
    pub bids: Vec<L2Level>,
    pub asks: Vec<L2Level>,
    pub update_id: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct L2Level {
    pub price: f64,
    pub size: f64,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum Side {
    Buy,
    Sell,
}

impl std::fmt::Display for Side {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Side::Buy => write!(f, "BUY"),
            Side::Sell => write!(f, "SELL"),
        }
    }
}

/// Alpha signal generated by a trading strategy.
///
/// # Description
/// Represents a high-level trading intent. Abstracted from specific order types,
/// a signal defines the desired side and quantity at a reference price.
///
/// # Fields
/// * `timestamp` - Generation time of the signal.
/// * `strategy_id` - Originating strategy component.
/// * `symbol` - Target asset identifier.
/// * `side` - Direction of the intent (Buy/Sell).
/// * `price` - Reference price for signal evaluation.
/// * `quantity` - Intended position size change.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SignalEvent {
    pub timestamp: DateTime<Utc>,
    pub strategy_id: String,
    pub symbol: String,
    pub side: Side,
    pub price: f64,
    pub quantity: f64,
    /// Unique identifier for the intent that generated this signal.
    pub intent_id: Option<Uuid>,

    // ========== HFT Decision Context (V2) ==========
    /// Best bid price at decision time
    #[serde(default)]
    pub decision_bid: f64,
    /// Best ask price at decision time
    #[serde(default)]
    pub decision_ask: f64,
    /// Mid price at decision time ((bid + ask) / 2)
    #[serde(default)]
    pub decision_mid: f64,
    /// Spread in basis points at decision time
    #[serde(default)]
    pub spread_bps: f64,
    /// Book timestamp (exchange time) in nanoseconds - for causality checks
    #[serde(default)]
    pub book_ts_ns: i64,
    /// Expected edge in basis points (from strategy signal)
    #[serde(default)]
    pub expected_edge_bps: f64,
}

/// Normalized order lifecycle event.
///
/// # Description
/// The primary vessel for order submission and status updates. Supports
/// multiple operation types through its payload.
///
/// # Fields
/// * `order_id` - RFC 4122 compliant unique identifier.
/// * `intent_id` - Link to the original strategy intent.
/// * `timestamp` - Event creation time.
/// * `symbol` - Asset symbol.
/// * `side` - Transaction side.
/// * `payload` - Functional intent ([`OrderPayload`]).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OrderEvent {
    pub order_id: Uuid,
    pub intent_id: Option<Uuid>,
    pub timestamp: DateTime<Utc>,
    pub symbol: String,
    pub side: Side,
    pub payload: OrderPayload,
}

/// Functional variants for order operations.
///
/// # Variants
/// * `New` - Submit a fresh order to the matching engine.
/// * `Update` - Status notification from the venue.
/// * `Modify` - Amend price or quantity of a pending order.
/// * `Cancel` - Request termination of an open order.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderPayload {
    New {
        symbol: String,
        side: Side,
        price: Option<f64>,
        quantity: f64,
        order_type: OrderType,
    },
    Update {
        status: OrderStatus,
        filled_quantity: f64,
        avg_price: f64,
        commission: f64,
    },
    /// Modify an existing order's price and/or quantity.
    Modify {
        /// New limit price (None = keep existing).
        new_price: Option<f64>,
        /// New quantity (None = keep existing).
        new_quantity: Option<f64>,
    },
    Cancel,
}

/// Specificity of execution execution logic.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderType {
    /// Immediate execution against available liquidity.
    Market,
    /// Execution only at or better than a specified price.
    Limit,
}

/// Lifecycle stages of a venue order.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum OrderStatus {
    /// Initial submission state.
    Pending,
    /// Confirmed by the exchange matching engine.
    Accepted,
    /// Refused by exchange or risk engine.
    Rejected,
    /// Partially filled; remaining quantity stays open.
    PartiallyFilled,
    /// Fully executed.
    Filled,
    /// Successfully withdrawn from the market.
    Cancelled,
}

/// Snapshot of a specific asset position.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PositionUpdate {
    pub symbol: String,
    pub quantity: f64,
    pub avg_price: f64,
    pub unrealized_pnl: f64,
}

/// Full state of the trading account at a point in time.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PortfolioSnapshot {
    pub timestamp: DateTime<Utc>,
    pub total_equity: f64,
    /// Available cash balance.
    pub cash: f64,
    /// Total margin used.
    pub margin_used: f64,
    pub positions: Vec<PositionUpdate>,
}

// ============================================================================
// RISK & SYSTEM EVENTS (C2 FIX)
// ============================================================================

/// Risk event for monitoring and alerting.
///
/// # Description
/// Published when risk limits are breached or approaching thresholds.
/// Enables real-time risk monitoring and circuit breaker triggers.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RiskEvent {
    /// Event timestamp.
    pub timestamp: DateTime<Utc>,
    /// Risk event type.
    pub event_type: RiskEventType,
    /// Affected symbol (if applicable).
    pub symbol: Option<String>,
    /// Affected strategy (if applicable).
    pub strategy_id: Option<String>,
    /// Current value that triggered the event.
    pub current_value: f64,
    /// Threshold that was breached.
    pub threshold: f64,
    /// Human-readable message.
    pub message: String,
}

/// Types of risk events.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum RiskEventType {
    /// Kill switch activated.
    KillSwitchTriggered,
    /// Order rejected by risk engine.
    OrderRejected,
    /// Position limit warning (approaching threshold).
    PositionLimitWarning,
    /// Position limit breached.
    PositionLimitBreached,
    /// Drawdown limit warning.
    DrawdownWarning,
    /// Drawdown limit breached.
    DrawdownBreached,
    /// Strategy circuit breaker tripped.
    StrategyCircuitBreaker,
    /// Daily loss limit reached.
    DailyLossLimit,
    /// Order rate limit exceeded.
    OrderRateLimit,
}

/// System health event for monitoring infrastructure.
///
/// # Description
/// Published for system-level events: connection status, latency spikes,
/// memory pressure, etc. Enables operational monitoring.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SystemHealthEvent {
    /// Event timestamp.
    pub timestamp: DateTime<Utc>,
    /// Health event type.
    pub event_type: SystemHealthType,
    /// Component that generated the event.
    pub component: String,
    /// Health status.
    pub status: HealthStatus,
    /// Additional details.
    pub details: Option<String>,
}

/// Types of system health events.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum SystemHealthType {
    /// Connector connection status change.
    ConnectorStatus,
    /// Latency spike detected.
    LatencySpike,
    /// Memory pressure warning.
    MemoryPressure,
    /// Disk space warning.
    DiskSpace,
    /// Message queue backlog.
    QueueBacklog,
    /// Heartbeat timeout.
    HeartbeatTimeout,
}

/// Health status levels.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum HealthStatus {
    /// System healthy.
    Healthy,
    /// Warning - degraded performance.
    Warning,
    /// Critical - action required.
    Critical,
    /// Component down.
    Down,
}

/// Fill event for trade audit trail.
///
/// # Description
/// Discrete event for each order fill, separate from OrderPayload::Update.
/// Enables detailed trade logging and reconciliation.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FillEvent {
    /// Fill timestamp.
    pub timestamp: DateTime<Utc>,
    /// Original order ID.
    pub order_id: Uuid,
    /// Link to the original strategy intent.
    pub intent_id: Option<Uuid>,
    /// Unique fill ID.
    pub fill_id: String,
    /// Symbol traded.
    pub symbol: String,
    /// Fill side.
    pub side: Side,
    /// Fill price.
    pub price: f64,
    /// Fill quantity.
    pub quantity: f64,
    /// Commission paid.
    pub commission: f64,
    /// Commission asset.
    pub commission_asset: String,
    /// Venue that executed the fill.
    pub venue: String,
    /// Whether this fill completed the order.
    pub is_final: bool,
}

// ============================================================================
// STRATEGY SANDBOXING (IPC MODELS)
// ============================================================================

/// Event sent from Runner to isolated Strategy Host.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum HostEvent {
    Start,
    Tick(MarketEvent),
    Bar(MarketEvent),
    Order(OrderEvent),
    Risk(RiskEvent),
    Timer(u64),
    Stop,
}

/// Response/Signal sent from isolated Strategy Host to Runner.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum HostResponse {
    Signal(SignalEvent),
    Ready,
}
